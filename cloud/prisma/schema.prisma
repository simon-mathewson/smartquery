generator client {
  provider      = "prisma-client-js"
  output        = "generated"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Connection {
  createdAt                          DateTime     @default(now())
  updatedAt                          DateTime     @updatedAt
  database                           String
  dbUser                             String
  encryptCredentials                 Boolean
  engine                             Engine
  host                               String
  name                               String
  password                           String?
  port                               Int
  schema                             String?
  sshHost                            String?
  sshPassword                        String?
  sshPort                            Int?
  sshPrivateKey                      String?
  sshUser                            String?
  passwordNonce                      String?
  sshPasswordNonce                   String?
  sshPrivateKeyNonce                 String?
  sshUsePrivateKey                   Boolean?
  id                                 String       @id @default(uuid()) @db.Uuid
  userId                             String       @db.Uuid
  sshPrivateKeyPassphrase            String?
  sshPrivateKeyPassphraseNonce       String?
  useSshPrivateKeyPassphrase         Boolean      @default(false)
  isSshPrivateKeyPassphraseEncrypted Boolean      @default(false)
  user                               User         @relation(fields: [userId], references: [id])
  savedQueries                       SavedQuery[]

  @@index([userId])
}

model RefreshToken {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())
  expiresAt DateTime
  token     String   @unique
  userId    String   @db.Uuid
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
}

model SavedQuery {
  id           String     @id @default(uuid()) @db.Uuid
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  connectionId String     @db.Uuid
  connection   Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  database     String?
  name         String
  sql          String
  userId       String     @db.Uuid
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([connectionId])
  @@index([connectionId, database])
}

model Subscription {
  id                   String           @id @default(uuid()) @db.Uuid
  createdAt            DateTime         @default(now())
  startDate            DateTime
  endDate              DateTime?
  type                 SubscriptionType
  userId               String           @db.Uuid
  user                 User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  activeForUser        User?            @relation("activeSubscription")
  stripeSubscriptionId String?          @unique
  stripeProductId      String?
  stripePriceId        String?

  @@index([userId])
}

model Usage {
  id        String    @id @default(uuid()) @db.Uuid
  userId    String    @db.Uuid
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime  @default(now())
  type      UsageType
  amount    Int

  @@index([userId, type, createdAt])
}

model User {
  createdAt              DateTime       @default(now())
  updatedAt              DateTime       @updatedAt
  email                  String         @unique
  password               String
  passwordSalt           String
  dataEncryptionKey      String
  dataEncryptionKeyNonce String
  keyEncryptionKeySalt   String
  id                     String         @id @default(uuid()) @db.Uuid
  isEmailVerified        Boolean        @default(false)
  emailVerificationToken String?        @unique
  resetPasswordToken     String?        @unique
  connections            Connection[]
  refreshTokens          RefreshToken[]
  subscriptions          Subscription[]
  usages                 Usage[]
  stripeCustomerId       String?        @unique
  activeSubscriptionId   String?        @unique @db.Uuid
  activeSubscription     Subscription?  @relation("activeSubscription", fields: [activeSubscriptionId], references: [id])
  savedQueries           SavedQuery[]

  @@index([emailVerificationToken])
  @@index([resetPasswordToken])
  @@index([stripeCustomerId])
}

enum Engine {
  mysql
  postgres
}

enum SubscriptionType {
  plus
  pro
}

enum UsageType {
  aiCredits
  queryDurationMilliseconds
  queryResponseBytes
}
